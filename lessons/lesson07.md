# 07、行锁

## 两阶段锁

InnoDB 事务中，行锁是在需要的时候才加上的，等到事务结束时才释放。这个就是两阶段锁协议。

> 如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

## 死锁和死锁检测

死锁：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态。

处理死锁的两种策略：
- 直接进入等待，直到超时；`innodb_lock_wait_timeout` 参数设置超时时间（通常不建议）；
- 发起**死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行；`innodb_deadlock_detect` 参数设置为 on ；

**死锁检测要耗费大量的 CPU 资源**

解决办法（核心思路 -- 控制、减少相同资源的并发事务量）：
- 如果确保这个业务一定不会出现死锁，可以临时把死锁检测关掉（通常不建议）；
- 控制并发度，并发控制做在数据库服务端或中间件；
- 从代码设计上进行优化，将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高；

innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。

